/*
Kafka Bridge API Reference

The Kafka Bridge provides a REST API for integrating HTTP based client applications with a Kafka cluster. You can use the API to create and manage consumers and send and receive records over HTTP rather than the native Kafka protocol. 

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kafka_bridge

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConsumersAPIService ConsumersAPI service
type ConsumersAPIService service

type ConsumersAPIAssignRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	partitions *Partitions
}

// List of topic partitions to assign to the consumer.
func (r ConsumersAPIAssignRequest) Partitions(partitions Partitions) ConsumersAPIAssignRequest {
	r.partitions = &partitions
	return r
}

func (r ConsumersAPIAssignRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignExecute(r)
}

/*
Assign Method for Assign

Assigns one or more topic partitions to a consumer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the consumer belongs.
 @param name Name of the consumer to assign topic partitions to.
 @return ConsumersAPIAssignRequest
*/
func (a *ConsumersAPIService) Assign(ctx context.Context, groupid string, name string) ConsumersAPIAssignRequest {
	return ConsumersAPIAssignRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) AssignExecute(r ConsumersAPIAssignRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Assign")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partitions == nil {
		return nil, reportError("partitions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partitions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPICommitRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	offsetCommitSeekList *OffsetCommitSeekList
}

// List of consumer offsets to commit to the consumer offsets commit log. You can specify one or more topic partitions to commit offsets for.
func (r ConsumersAPICommitRequest) OffsetCommitSeekList(offsetCommitSeekList OffsetCommitSeekList) ConsumersAPICommitRequest {
	r.offsetCommitSeekList = &offsetCommitSeekList
	return r
}

func (r ConsumersAPICommitRequest) Execute() (*http.Response, error) {
	return r.ApiService.CommitExecute(r)
}

/*
Commit Method for Commit

Commits a list of consumer offsets. To commit offsets for all records fetched by the consumer, leave the request body empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the consumer belongs.
 @param name Name of the consumer.
 @return ConsumersAPICommitRequest
*/
func (a *ConsumersAPIService) Commit(ctx context.Context, groupid string, name string) ConsumersAPICommitRequest {
	return ConsumersAPICommitRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) CommitExecute(r ConsumersAPICommitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Commit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/offsets"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.offsetCommitSeekList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPICreateConsumerRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	consumer *Consumer
}

// Name and configuration of the consumer. The name is unique within the scope of the consumer group. If a name is not specified, a randomly generated name is assigned. All parameters are optional. The supported configuration options are shown in the following example.
func (r ConsumersAPICreateConsumerRequest) Consumer(consumer Consumer) ConsumersAPICreateConsumerRequest {
	r.consumer = &consumer
	return r
}

func (r ConsumersAPICreateConsumerRequest) Execute() (*CreatedConsumer, *http.Response, error) {
	return r.ApiService.CreateConsumerExecute(r)
}

/*
CreateConsumer Method for CreateConsumer

Creates a consumer instance in the given consumer group. You can optionally specify a consumer name and supported configuration options. It returns a base URI which must be used to construct URLs for subsequent requests against this consumer instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group in which to create the consumer.
 @return ConsumersAPICreateConsumerRequest
*/
func (a *ConsumersAPIService) CreateConsumer(ctx context.Context, groupid string) ConsumersAPICreateConsumerRequest {
	return ConsumersAPICreateConsumerRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
	}
}

// Execute executes the request
//  @return CreatedConsumer
func (a *ConsumersAPIService) CreateConsumerExecute(r ConsumersAPICreateConsumerRequest) (*CreatedConsumer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatedConsumer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.CreateConsumer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.consumer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConsumersAPIDeleteConsumerRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
}

func (r ConsumersAPIDeleteConsumerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConsumerExecute(r)
}

/*
DeleteConsumer Method for DeleteConsumer

Deletes a specified consumer instance. The request for this operation MUST use the base URL (including the host and port) returned in the response from the `POST` request to `/consumers/{groupid}` that was used to create this consumer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the consumer belongs.
 @param name Name of the consumer to delete.
 @return ConsumersAPIDeleteConsumerRequest
*/
func (a *ConsumersAPIService) DeleteConsumer(ctx context.Context, groupid string, name string) ConsumersAPIDeleteConsumerRequest {
	return ConsumersAPIDeleteConsumerRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) DeleteConsumerExecute(r ConsumersAPIDeleteConsumerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.DeleteConsumer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPIListSubscriptionsRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
}

func (r ConsumersAPIListSubscriptionsRequest) Execute() (*SubscribedTopicList, *http.Response, error) {
	return r.ApiService.ListSubscriptionsExecute(r)
}

/*
ListSubscriptions Method for ListSubscriptions

Retrieves a list of the topics to which the consumer is subscribed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the subscribed consumer.
 @return ConsumersAPIListSubscriptionsRequest
*/
func (a *ConsumersAPIService) ListSubscriptions(ctx context.Context, groupid string, name string) ConsumersAPIListSubscriptionsRequest {
	return ConsumersAPIListSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
//  @return SubscribedTopicList
func (a *ConsumersAPIService) ListSubscriptionsExecute(r ConsumersAPIListSubscriptionsRequest) (*SubscribedTopicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscribedTopicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.ListSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConsumersAPIPollRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	timeout *int32
	maxBytes *int32
}

// The maximum amount of time, in milliseconds, that the HTTP Bridge spends retrieving records before timing out the request.
func (r ConsumersAPIPollRequest) Timeout(timeout int32) ConsumersAPIPollRequest {
	r.timeout = &timeout
	return r
}

// The maximum size, in bytes, of unencoded keys and values that can be included in the response. Otherwise, an error response with code 422 is returned.
func (r ConsumersAPIPollRequest) MaxBytes(maxBytes int32) ConsumersAPIPollRequest {
	r.maxBytes = &maxBytes
	return r
}

func (r ConsumersAPIPollRequest) Execute() ([]ConsumerRecord, *http.Response, error) {
	return r.ApiService.PollExecute(r)
}

/*
Poll Method for Poll

Retrieves records for a subscribed consumer, including message values, topics, and partitions. The request for this operation MUST use the base URL (including the host and port) returned in the response from the `POST` request to `/consumers/{groupid}` that was used to create this consumer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the subscribed consumer to retrieve records from.
 @return ConsumersAPIPollRequest
*/
func (a *ConsumersAPIService) Poll(ctx context.Context, groupid string, name string) ConsumersAPIPollRequest {
	return ConsumersAPIPollRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
//  @return []ConsumerRecord
func (a *ConsumersAPIService) PollExecute(r ConsumersAPIPollRequest) ([]ConsumerRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsumerRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Poll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "form", "")
	}
	if r.maxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_bytes", r.maxBytes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.json.v2+json", "application/vnd.kafka.binary.v2+json", "application/vnd.kafka.text.v2+json", "application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConsumersAPISeekRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	offsetCommitSeekList *OffsetCommitSeekList
}

// List of partition offsets from which the subscribed consumer will next fetch records.
func (r ConsumersAPISeekRequest) OffsetCommitSeekList(offsetCommitSeekList OffsetCommitSeekList) ConsumersAPISeekRequest {
	r.offsetCommitSeekList = &offsetCommitSeekList
	return r
}

func (r ConsumersAPISeekRequest) Execute() (*http.Response, error) {
	return r.ApiService.SeekExecute(r)
}

/*
Seek Method for Seek

Configures a subscribed consumer to fetch offsets from a particular offset the next time it fetches a set of records from a given topic partition. This overrides the default fetch behavior for consumers. You can specify one or more topic partitions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the consumer belongs.
 @param name Name of the subscribed consumer.
 @return ConsumersAPISeekRequest
*/
func (a *ConsumersAPIService) Seek(ctx context.Context, groupid string, name string) ConsumersAPISeekRequest {
	return ConsumersAPISeekRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) SeekExecute(r ConsumersAPISeekRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Seek")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/positions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offsetCommitSeekList == nil {
		return nil, reportError("offsetCommitSeekList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.offsetCommitSeekList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPISeekToBeginningRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	partitions *Partitions
}

// List of topic partitions to which the consumer is subscribed. The consumer will seek the first offset in the specified partitions.
func (r ConsumersAPISeekToBeginningRequest) Partitions(partitions Partitions) ConsumersAPISeekToBeginningRequest {
	r.partitions = &partitions
	return r
}

func (r ConsumersAPISeekToBeginningRequest) Execute() (*http.Response, error) {
	return r.ApiService.SeekToBeginningExecute(r)
}

/*
SeekToBeginning Method for SeekToBeginning

Configures a subscribed consumer to seek (and subsequently read from) the first offset in one or more given topic partitions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the subscribed consumer.
 @return ConsumersAPISeekToBeginningRequest
*/
func (a *ConsumersAPIService) SeekToBeginning(ctx context.Context, groupid string, name string) ConsumersAPISeekToBeginningRequest {
	return ConsumersAPISeekToBeginningRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) SeekToBeginningExecute(r ConsumersAPISeekToBeginningRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.SeekToBeginning")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/positions/beginning"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partitions == nil {
		return nil, reportError("partitions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partitions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPISeekToEndRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	partitions *Partitions
}

// List of topic partitions to which the consumer is subscribed. The consumer will seek the last offset in the specified partitions.
func (r ConsumersAPISeekToEndRequest) Partitions(partitions Partitions) ConsumersAPISeekToEndRequest {
	r.partitions = &partitions
	return r
}

func (r ConsumersAPISeekToEndRequest) Execute() (*http.Response, error) {
	return r.ApiService.SeekToEndExecute(r)
}

/*
SeekToEnd Method for SeekToEnd

Configures a subscribed consumer to seek (and subsequently read from) the offset at the end of one or more of the given topic partitions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the subscribed consumer.
 @return ConsumersAPISeekToEndRequest
*/
func (a *ConsumersAPIService) SeekToEnd(ctx context.Context, groupid string, name string) ConsumersAPISeekToEndRequest {
	return ConsumersAPISeekToEndRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) SeekToEndExecute(r ConsumersAPISeekToEndRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.SeekToEnd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/positions/end"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partitions == nil {
		return nil, reportError("partitions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partitions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPISubscribeRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
	topics *Topics
}

// List of topics to which the consumer will subscribe.
func (r ConsumersAPISubscribeRequest) Topics(topics Topics) ConsumersAPISubscribeRequest {
	r.topics = &topics
	return r
}

func (r ConsumersAPISubscribeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscribeExecute(r)
}

/*
Subscribe Method for Subscribe

Subscribes a consumer to one or more topics. You can describe the topics to which the consumer will subscribe in a list (of `Topics` type) or as a `topic_pattern` field. Each call replaces the subscriptions for the subscriber.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the consumer to subscribe to topics.
 @return ConsumersAPISubscribeRequest
*/
func (a *ConsumersAPIService) Subscribe(ctx context.Context, groupid string, name string) ConsumersAPISubscribeRequest {
	return ConsumersAPISubscribeRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) SubscribeExecute(r ConsumersAPISubscribeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Subscribe")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.topics == nil {
		return nil, reportError("topics is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.kafka.v2+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.kafka.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.topics
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConsumersAPIUnsubscribeRequest struct {
	ctx context.Context
	ApiService *ConsumersAPIService
	groupid string
	name string
}

func (r ConsumersAPIUnsubscribeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnsubscribeExecute(r)
}

/*
Unsubscribe Method for Unsubscribe

Unsubscribes a consumer from all topics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupid ID of the consumer group to which the subscribed consumer belongs.
 @param name Name of the consumer to unsubscribe from topics.
 @return ConsumersAPIUnsubscribeRequest
*/
func (a *ConsumersAPIService) Unsubscribe(ctx context.Context, groupid string, name string) ConsumersAPIUnsubscribeRequest {
	return ConsumersAPIUnsubscribeRequest{
		ApiService: a,
		ctx: ctx,
		groupid: groupid,
		name: name,
	}
}

// Execute executes the request
func (a *ConsumersAPIService) UnsubscribeExecute(r ConsumersAPIUnsubscribeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConsumersAPIService.Unsubscribe")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumers/{groupid}/instances/{name}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"groupid"+"}", url.PathEscape(parameterValueToString(r.groupid, "groupid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
